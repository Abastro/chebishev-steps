module Inductive (
  InductSeq,
  makeSeq,
  seqValue,
  seqPrev,
  seqNext,
  Induction (..),
  addBase,
  mapInduction,
  zipInduction,
  Inductive (..),
  inductive,
  inductNum,
  inputs,
  nexts,
) where

import Data.Bifunctor (Bifunctor (..))
import Data.Foldable (Foldable (..))
import Data.Sequence qualified as Seq

-- | Induction sequence describes the computed values from induction giving [a] -> v.
--
-- All the inputs are recorded as well, since the induction can look into previous inputs as well.
data InductSeq a v = InductSeq
  { initial :: v,
    result :: Seq.Seq (a, v)
  }
  deriving (Eq, Show, Functor)

makeSeq :: v -> InductSeq a v
makeSeq initial = InductSeq{initial, result = Seq.Empty}

seqValue :: InductSeq a v -> v
seqValue cur = case cur.result of
  Seq.Empty -> cur.initial
  _ Seq.:|> (_, value) -> value

seqPrev :: InductSeq a v -> Maybe (a, InductSeq a v)
seqPrev cur = case cur.result of
  Seq.Empty -> Nothing
  prev Seq.:|> (inp, _) -> Just (inp, cur{result = prev})

seqNext :: Induction a v -> a -> InductSeq a v -> InductSeq a v
seqNext induction inp cur = cur{result = cur.result Seq.|> (inp, induction.step inp cur)}

-- | A description of an induction process.
data Induction a v = Induction
  { base :: v,
    step :: a -> InductSeq a v -> v
  }

-- >>> listInduction = Induction{base = [], step = \inp iseq -> inp : seqValue iseq}
-- >>> basedList = inductive (addBase [] listInduction)
-- >>> basedShiftedList = inductive (addBaseShifted [] listInduction)
-- >>> bbsList = inductive (addBase [] . addBaseShifted [] $ listInduction)
-- >>> bbsList2 = inductive (addBaseShifted [] . addBase [] $ listInduction)
-- >>> (nexts basedList [1..5]).value
-- >>> (nexts basedShiftedList [1..5]).value
-- >>> (nexts bbsList [1..5]).value
-- >>> (nexts bbsList2 [1..5]).value
-- [5,4,3,2]
-- [4,3,2,1]
-- [4,3,2]
-- [4,3,2,1]

-- | Add additional base case to the induction, ignoring the first input.
addBase :: v -> Induction a v -> Induction a v
addBase aBase ind =
  Induction
    { base = aBase,
      step = \inp iseq -> case iseq.result of
        Seq.Empty -> ind.base
        _ Seq.:<| withIgnore -> ind.step inp (InductSeq ind.base withIgnore)
    }

-- | Add additional base case to the induction, shifting inputs as well.
--
-- First input is applied to the second output, second to third, etc.
-- addBaseShifted :: v -> Induction a v -> Induction a v
-- addBaseShifted aBase ind =
--   Induction
--     { base = aBase,
--       step = \_ iseq -> case iseq.result of
--         Seq.Empty -> ind.base
--         pprev Seq.:|> (prevInp, prevVal) ->
--           let inps = fst <$> pprev
--               vals = (snd <$> pprev) Seq.|> prevVal
--            in ind.step prevInp iseq
--     }

-- | Maps an induction by bijection.
mapInduction :: (v -> w) -> (w -> v) -> Induction a v -> Induction a w
mapInduction front back ind =
  Induction
    { base = front ind.base,
      step = \inp iseq -> front $ ind.step inp $ fmap back iseq
    }

-- | Zips two induction into one.
zipInduction :: Induction a v -> Induction a w -> Induction a (v, w)
zipInduction indL indR =
  Induction
    { base = (indL.base, indR.base),
      step = \inp iseq -> (indL.step inp $ fst <$> iseq, indR.step inp $ snd <$> iseq)
    }

-- | A 'sequence' generated by induction.
data Inductive a v = Inductive
  { evaluated :: InductSeq a v,
    previous :: Maybe (a, Inductive a v),
    next :: a -> Inductive a v,
    value :: v
  }

inductive :: Induction a v -> Inductive a v
inductive induction = inductiveFrom (makeSeq induction.base)
 where
  inductiveFrom iseq =
    Inductive
      { evaluated = iseq,
        previous = second inductiveFrom <$> seqPrev iseq,
        next = \inp -> inductiveFrom $ seqNext induction inp iseq,
        value = seqValue iseq
      }

inductNum :: Inductive a v -> Int
inductNum ind = Seq.length ind.evaluated.result

inputs :: Inductive a v -> [a]
inputs ind = fst <$> toList ind.evaluated.result

nexts :: Inductive a v -> [a] -> Inductive a v
nexts = foldl' (\cur inp -> cur.next inp)

-- -- | Note that the initial value is 0.
-- valueAt :: Int -> InductiveEval a v -> Maybe v
-- valueAt 0 eval = Just eval.initial
-- valueAt i eval = snd <$> eval.evaluated Seq.!? (i - 1)

-- -- | To match with valueAt, input starts at 1.
-- inputAt :: Int -> InductiveEval a v -> Maybe a
-- inputAt i eval = fst <$> eval.evaluated Seq.!? (i - 1)
