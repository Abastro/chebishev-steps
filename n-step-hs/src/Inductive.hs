module Inductive (
  InductSeq,
  makeSeq,
  seqValue,
  seqPrev,
  seqNext,
  Induction (..),
  mapInduction,
  zipInduction,
  Inductive (..),
  inductive,
  inductNum,
  inputs,
  nexts,
) where

import Data.Bifunctor (Bifunctor (..))
import Data.Foldable (Foldable (..))
import Data.Sequence qualified as Seq

-- | Induction sequence describes the computed values from induction giving [a] -> v.
data InductSeq a v = InductSeq
  { initial :: v,
    result :: Seq.Seq (a, v)
  }
  deriving (Eq, Show, Functor)

makeSeq :: v -> InductSeq a v
makeSeq initial = InductSeq{initial, result = Seq.Empty}

seqValue :: InductSeq a v -> v
seqValue cur = case cur.result of
  Seq.Empty -> cur.initial
  _ Seq.:|> (_, value) -> value

seqPrev :: InductSeq a v -> Maybe (a, InductSeq a v)
seqPrev cur = case cur.result of
  Seq.Empty -> Nothing
  prev Seq.:|> (inp, _) -> Just (inp, cur{result = prev})

seqNext :: Induction a v -> a -> InductSeq a v -> InductSeq a v
seqNext induction inp cur = cur{result = cur.result Seq.|> (inp, induction.step inp cur)}

-- | A description of an induction process.
data Induction a v = Induction
  { base :: v,
    step :: a -> InductSeq a v -> v
  }

-- | Maps an induction by bijection.
mapInduction :: (v -> w) -> (w -> v) -> Induction a v -> Induction a w
mapInduction front back ind =
  Induction
    { base = front ind.base,
      step = \inp iseq -> front $ ind.step inp $ fmap back iseq
    }

-- | Zips two induction into one.
zipInduction :: Induction a v -> Induction a w -> Induction a (v, w)
zipInduction indL indR =
  Induction
    { base = (indL.base, indR.base),
      step = \inp iseq -> (indL.step inp $ fst <$> iseq, indR.step inp $ snd <$> iseq)
    }

-- | A 'sequence' generated by induction.
data Inductive a v = Inductive
  { evaluated :: InductSeq a v,
    previous :: Maybe (a, Inductive a v),
    next :: a -> Inductive a v,
    value :: v
  }

inductive :: Induction a v -> Inductive a v
inductive induction = inductiveFrom (makeSeq induction.base)
 where
  inductiveFrom iseq =
    Inductive
      { evaluated = iseq,
        previous = second inductiveFrom <$> seqPrev iseq,
        next = \inp -> inductiveFrom $ seqNext induction inp iseq,
        value = seqValue iseq
      }

inductNum :: Inductive a v -> Int
inductNum ind = Seq.length ind.evaluated.result

inputs :: Inductive a v -> [a]
inputs ind = fst <$> toList ind.evaluated.result

nexts :: Inductive a v -> [a] -> Inductive a v
nexts = foldl' (\cur inp -> cur.next inp)

-- -- | Note that the initial value is 0.
-- valueAt :: Int -> InductiveEval a v -> Maybe v
-- valueAt 0 eval = Just eval.initial
-- valueAt i eval = snd <$> eval.evaluated Seq.!? (i - 1)

-- -- | To match with valueAt, input starts at 1.
-- inputAt :: Int -> InductiveEval a v -> Maybe a
-- inputAt i eval = fst <$> eval.evaluated Seq.!? (i - 1)
